<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>可视化——排序</title>
</head>
<body>


<script>

    function createRandomArr(l) {
        var arr = [];
        for(let i = 0;i<l;i++){
            arr.push(Math.floor(Math.random()*l+1));
        }
        return arr;
    }

    // console.log(createRandomArr(10));

    function createBestArr(l) {
        var arr = [];
        for(let i = 0;i<l;i++){
            arr.push(i);
        }
        return arr;
    }


    // 冒泡排序
    function BubbleSort(arr) {

        var clone_arr = arr.map(function (e) {
            return e;
        })
        console.time('冒泡排序');
        // 每趟都把最大的找出来，长度为10的话外层需要循环9趟；
        for(let i = 1;i<clone_arr.length;i++){
            for (let j = 0;j<clone_arr.length - i; j++){
                if(clone_arr[j]>clone_arr[j+1]){
                    var temp = clone_arr[j+1];
                    clone_arr[j+1] = clone_arr[j];
                    clone_arr[j] = temp;
                }
            }
        }
        console.timeEnd('冒泡排序');
        return clone_arr;
    }

    // 选择排序
    function SelectSort(arr) {
        var clone_arr = arr.map(function (e) {
            return e;
        })
        console.time('选择排序');
        // 和冒泡排序类似，冒泡排序循环一次，每次都是比较相邻的两个元素大小
        // 选择排序是首先把第一个元素作为最大（小）的元素，然后循环找出比第一个元素更小的元素，然后替换
        // 也是需要循环n-1次，
        for(let i = 0;i<clone_arr.length -1 ;i++) {
            var minIndex = i;
            for(let j = i + 1; j< clone_arr.length;j++){
                if(clone_arr[j] < clone_arr[minIndex]){
                    minIndex = j;
                }
            }
            // 替换i和maxIndex两个元素
            if(i != minIndex){
                var temp = clone_arr[minIndex];
                clone_arr[minIndex] = clone_arr[i];
                clone_arr[i] = temp;
            }
        }
        console.timeEnd('选择排序');
        return clone_arr;
    }

    // 插入排序
    function InsertSort(arr){
        var new_arr = [];
        new_arr.push(arr[0]);
        console.time('插入排序');
        for(let i=1;i<arr.length;i++){
            for(let j = 0;j<new_arr.length;j++){
                if(arr[i] <= new_arr[j]){
                    new_arr.splice(j,0,arr[i]);
                    break;
                }else if(j == new_arr.length-1){
                    new_arr.push(arr[i]);
                }
            }
        }
        console.timeEnd('插入排序');
        return new_arr;
    }

    // 阮一峰版本，速度特别慢
    // 网上指出阮一峰是错的（获取pivot使用spilce）。
    // 我改成了直接通过下标获取中间值。
    // 由于每次递归都新建了 left[] 和 right[] 所以占用空间会比较大
    // 快速排序
    function QuickSort(arr) {
        if(arr.length <= 1){
            return arr;
        }
        var pivotIndex=Math.floor(arr.length/2);
        var pivot=arr[pivotIndex];
        //定义左右数组
        var left=[];
        var right=[];
        //比基准小的放在left，比基准大的放在right
        for(var i=0;i<arr.length;i++){
            if(i != pivotIndex){
                if(arr[i]<=pivot){
                    left.push(arr[i]);
                }
                else{
                    right.push(arr[i]);
                }
            }
        }
        //递归
        return QuickSort(left).concat([pivot],QuickSort(right));
    }

    // 网上优化版
    // https://juejin.im/post/5af4902a6fb9a07abf728c40


    // 为了测试快速排序的时间
    function quicksort(arr) {
        console.time('快速排序');
        var a =  QuickSort(arr);
        console.timeEnd('快速排序');
        return a;
    }

    var arr = createRandomArr(10);
    console.group('一般情况');
    console.log(arr);
    console.log(BubbleSort(arr));
    console.log(SelectSort(arr));
    console.log(InsertSort(arr));

    console.log(quicksort(arr));

    // var best_arr = createBestArr(10);
    // console.group('最好情况');
    // console.log(best_arr);
    // console.log(BubbleSort(best_arr));
    // console.log(SelectSort(best_arr));
</script>
</body>
</html>